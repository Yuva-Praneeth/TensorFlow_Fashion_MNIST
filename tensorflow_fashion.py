# -*- coding: utf-8 -*-
"""TensorFlow_Fashion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Le6KEc6wX5m51We_30mHPjYSt6OBdKPP
"""

import numpy as np
import matplotlib.pyplot as plt

import tensorflow as tf

(x_train , y_train) , (x_test , y_test) = tf.keras.datasets.fashion_mnist.load_data()

x_train.shape

x_test.shape

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 2.x
import tensorflow as tf
print("Tenserflow version " + tf.__version__)

x_train = x_train.astype('float32')
x_test = x_test.astype('float32')

L_grid = 4
W_grid = 4

fig, axes = plt.subplots(L_grid, W_grid, figsize=(25, 25))
axes = axes.ravel()

n_training = len(x_train)

import random

for i in range(0, L_grid * W_grid):
    index = random.randint(0, n_training)
    axes[i].imshow(x_train[index])
    axes[i].set_title(y_train[index])
    axes[i].axis('off')

plt.subplots_adjust(hspace=0.3)

#Remember the 10 classes decoding is as follows:
#0=>T-shirt/top
#1=> Trouser
#2=> Pullover
#3=> Dress
#4=> Coat
#5=> Sandal
#6=>Shirt
#7=> Sneaker
#8=>Bag
#9=> Ankle boot

x_train = np.expand_dims(x_train , -1)
x_test = np.expand_dims(x_test , -1)

x_train.shape

x_test.shape

x_train = x_train/255
x_test = x_test/255

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

def create_model():
    classifier = Sequential()
    classifier.add(Conv2D(filters=64, kernel_size=(3, 3), activation='relu', input_shape=(28, 28, 1)))
    classifier.add(MaxPooling2D((2, 2)))
    classifier.add(Dropout(0.2))
    classifier.add(Conv2D(filters=64, kernel_size=(3, 3), activation='relu'))
    classifier.add(MaxPooling2D((2, 2)))
    classifier.add(Dropout(0.2))
    classifier.add(Flatten())
    classifier.add(Dense(units=128, activation='relu'))
    classifier.add(Dense(units=10, activation='softmax'))
    return classifier

strategy = tf.distribute.MirroredStrategy()  # You can use MirroredStrategy for GPU if TPU is not available

with strategy.scope():
    model = create_model()
    model.compile(
        optimizer=tf.keras.optimizers.Adam(learning_rate=1e-3),
        loss='sparse_categorical_crossentropy',
        metrics=['sparse_categorical_accuracy']
    )

model.fit(x_train.astype(np.float32) , y_train.astype(np.float32) , epochs = 2 , batch_size=32)

y_predict_prob = model.predict(x_test)
y_predict_classes = tf.argmax(y_predict_prob, axis=1)

y_predict_prob

from sklearn.metrics import confusion_matrix
import numpy as np
y_test_numpy = np.array(y_test)

# Create the confusion matrix
cm = confusion_matrix(y_test_numpy, y_predict_classes)

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming you have already calculated the confusion matrix 'cm'
sns.heatmap(cm, annot=True)

# Add labels to the axes
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')

plt.show()

from sklearn.metrics import accuracy_score

accuracy = accuracy_score(y_test, y_predict_classes)
print("Accuracy:", accuracy)

import matplotlib.pyplot as plt
import random

l = 2
w = 10

# Create a figure with subplots
fig, axes = plt.subplots(1, w, figsize=(25, 25))
axes = axes.ravel()

# Iterate over the subplots
for i in range(0, w):
    index = random.randint(0, len(x_test) - 1)  # Corrected index range
    axes[i].imshow(tf.squeeze(x_test[index]))
    axes[i].set_title('Prediction class: {}\nTrue class: {}'.format(y_predict_classes[index], y_test[index]))
    axes[i].axis('off')

plt.subplots_adjust(wspace=0.3)
plt.show()

from sklearn.metrics import precision_score, recall_score, f1_score

# Assuming y_test and y_predict_classes are your ground truth and predicted labels
# y_test and y_predict_classes should be numpy arrays for scikit-learn metrics
y_test_numpy = np.array(y_test)

# Calculate precision
precision = precision_score(y_test_numpy, y_predict_classes, average='weighted')
print("Precision:", precision)

# Calculate recall
recall = recall_score(y_test_numpy, y_predict_classes, average='weighted')
print("Recall:", recall)

# Calculate F1 score
f1 = f1_score(y_test_numpy, y_predict_classes, average='weighted')
print("F1 Score:", f1)

